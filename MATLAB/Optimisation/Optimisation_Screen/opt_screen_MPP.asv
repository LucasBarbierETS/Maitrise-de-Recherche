% Cette fonction a pour but d'optimiser les paramètres d'un écran résistif rigide perforé, 
% modélisé à l'aide du modèle de fluide équivalent (JCA) appliqué au cas des plaques microperforées (MPP)
% Cette fonction cherche à trouver le(s) groupe(s) de paramètres qui
% "neutralise(nt)" l'effet d'un écran résistif placé à une certaine distance de la solution

function x_opti = opt_screen_MPP(solution, distance, env, screen_handle, fmin, fmax, x0, lb, ub)

    arguments
        solution {mustBeA(solution, 'classelement')}
        distance double
        env
        screen_handle function_handle = @(phi, r, t, s) classMPP_Circular(classMPP_Circular.create_config(phi, r, t, s))
        fmin double = 150
        fmax double = 400
        x0 double = [5e-2, 1e-3, 1e-3]
        lb double = [1e-2 1e-4 5e-4]
        ub double = [15e-2 3e-3 3e-3]  
        
    end

    input_section = solution.Configuration.InputSection;
    serial_handle_assembly = @(params) classelement( ...
                                                classelement.create_config( ...
                                                    {screen_handle(params{:}, input_section), ...
                                                    classcavity(classcavity.create_config(distance, input_section)), ...
                                                    solution), ...
                                                'closed', input_section);

    % On définit l'intervale fréquenciel d'évaluation de la fonction coût
    g = @(env) (env.w / (2*pi) > fmin & env.w / (2*pi) < fmax);

    % On calcule la différence entre le coefficient d'absorption avec et sans l'écran
    cost_function = @(params, env) sum(((serial_handle_assembly(num2cell(params)).alpha(env) ... % avec
                                         - solution.alpha(env)) ... % sans
                                            .* (g(env) > 0.1)) ... % filtrage de la bande de fréquence d'interêt
                                                .^2);

    objective = @(params) cost_function(params, env);

    % On optimise à l'aide de l'algorithme génétique
    options = optimoptions('ga', 'Display', 'iter', 'MaxGenerations', 30);
    [x_opti, ~] = ga(objective, length(x0), [], [], [], [], lb, ub, [], [], options);
end
