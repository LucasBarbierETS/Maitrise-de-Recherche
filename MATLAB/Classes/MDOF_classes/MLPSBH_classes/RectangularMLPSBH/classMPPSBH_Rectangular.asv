classdef classMPPSBH_Rectangular < classelement

    methods
        function obj = classMPPSBH_Rectangular(config)
        
            % Appel du constructeur de la classe parente
            obj@classelement(classelement.create_config({}, 'closed'));
               
            if nargin > 0    
                % Transfert des champs de la configuration d'appel vers la configuration de classe
                obj.Configuration = perso_transfer_fields(config, obj.Configuration);
    
                cavw = config.CavitiesWidth;
                cavd = config.CavitiesDepth;
                sw = config.SlitsWidth;
                pp = config.PlatesPerforatedPartPorosity;
                phr = config.PlatesHolesRadius;
                pt = config.PlatesThickness;
                ct = config.CavitiesThickness;

                % On ajoute p√©ridiquement la cellule plaque + cavit√©
                for i = 1:length(pp)

                    obj.Configuration.ListOfSubelements{end+1} = Cell_MPPSBHr(Cell_MPPSBHr.create_config(pp(i), phr(i), pt(i), ...
                    ct(i), cavd, cavw, sw(i),  sw(i+1)));
                end 
            end
        end
    
        function output_model = set_COMSOL_2D_Model(obj, input_model, index, env)
            output_model = ModelMPPSBH(obj.Configuration, input_model, index, env);
        end
    
        function export_plate_hole_coordinates(obj, folder_name, sfx)
            % Cr√©e un dossier de configuration et y exporte les coordonn√©es des trous pour chaque plaque
        
            config = obj.Configuration;
        
            % R√©cup√©ration des donn√©es
            N = config.NumberOfPlates;
            radius = round(config.PlatesHolesRadius, 5);  % Rayon en m√®tres
            spacing = round(config.PlatesWidthHolesDistance, 5);
            num_rows_array = config.PlatesDepthHolesNumber;
            num_cols_array = config.PlatesWidthHolesNumber;
            depth = config.CavitiesDepth - 2e-3;

            % Dossier racine des configurations
            coord_dir = fullfile(folder_name, 'Coordonn√©es des perforations');
        
            % Cr√©ation des dossiers si n√©cessaires
            if ~exist(folder_name, 'dir')
                mkdir(folder_name);
            end
            if ~exist(coord_dir, 'dir')
                mkdir(coord_dir);
            end
        
            % Export des coordonn√©es pour chaque plaque
            for i = 1:N
                nx = num_cols_array(i);
                ny = num_rows_array(i);
        
                % Coordonn√©es en mm
                total_width = (nx - 1) * spacing(i);
                x_start = -total_width / 2;
                x_positions = x_start + (0:(nx - 1)) * spacing(i);
                spacing_y = depth / (ny + 1);
                y_positions = linspace(-depth / 2 + spacing_y, depth / 2 - spacing_y, ny);
        
                [X, Y] = meshgrid(x_positions, y_positions);
                hole_coordinates = [X(:), Y(:)] * 1e3;  % mm
                hole_radius = radius(i) * 1e3;  % rayon en mm
        
                % Fichier CSV de la plaque
                filename = fullfile(coord_dir, sprintf('plaque_%02d%s.csv', i, sfx));
                fileID = fopen(filename, 'w');
        
                if fileID == -1
                    error('[‚úó] Impossible de cr√©er le fichier : %s', filename);
                end
        
                fprintf(fileID, 'X,Y,R\n');  % En-t√™te CSV
        
                for j = 1:size(hole_coordinates, 1)
                    fprintf(fileID, '%.2f,%.2f,%.3f\n', ...
                        hole_coordinates(j, 1), ...
                        hole_coordinates(j, 2), ...
                        hole_radius);
                end
        
                fclose(fileID);
                fprintf('[‚úì] Coordonn√©es export√©es : %s\n', filename);
            end
        
            fprintf('[‚úì] Tous les fichiers de coordonn√©es ont √©t√© export√©s dans : %s\n', coord_dir);
        end

        function launch_in_solidworks(obj, folder_name)
            % Lancer l'export et le script Python avec cr√©ation de dossiers et ouverture de l'explorateur
        
            % === 1. D√©finition des chemins ===
            base_root = 'E:\OneDrive - ETS\CRIAQ-REAR\Maitrise LB\MATLAB\Classes\MDOF_classes\MLPSBH_classes\RectangularMLPSBH\Configurations';
            output_dir = fullfile(base_root, folder_name);
        
            % === 2. Cr√©ation du dossier principal si n√©cessaire ===
            if ~exist(output_dir, 'dir')
                mkdir(output_dir);
                fprintf('[‚úì] Dossier cr√©√© : %s\n', output_dir);
            else
                fprintf('[i] Dossier d√©j√† existant : %s\n', output_dir);
            end
        
            % === 3. Exporter les coordonn√©es ===
            obj.export_plate_hole_coordinates(folder_name);
        
            % === 4. Appel du script Python ===
            py_script = 'E:\OneDrive - ETS\CRIAQ-REAR\Maitrise LB\MATLAB\Classes\MDOF_classes\MLPSBH_classes\RectangularMLPSBH\MATLAB to SOLIDWORKS\build_MPPSBH_from_json.py';
            command = sprintf('python "%s" "%s"', py_script, output_dir);
        
            fprintf('[‚ñ∂] Lancement du script Python :\n%s\n', command);
            [status, output] = system(command);
            disp(output);
        
            % === 5. V√©rification de l'ex√©cution ===
            if status ~= 0
                error('[‚úó] √âchec de l‚Äôex√©cution Python.');
            else
                fprintf('[‚úì] Script Python termin√© avec succ√®s.\n');
            end
        
            % === 6. Ouverture automatique du dossier ===
            fprintf('[üìÇ] Ouverture du dossier dans l‚Äôexplorateur...\n');
            system(sprintf('explorer "%s"', output_dir));
        end
    
        function export_report(obj, filename)
            
            config = obj.Configuration;

            % === Nom par d√©faut si non sp√©cifi√© ===
            if nargin < 2
                filename = fullfile(pwd, 'porosity_report.xlsx');
            end
        
            % === V√©rifie et cr√©e le dossier si n√©cessaire ===
            folder = fileparts(filename);
            if ~isempty(folder) && ~isfolder(folder)
                mkdir(folder);
            end
        
            % === Supprime un fichier d√©j√† existant s‚Äôil est bloqu√© ===
            if exist(filename, 'file')
                try
                    delete(filename);
                catch
                    error("Impossible de supprimer %s. Ferme Excel ou change de nom.", filename);
                end
            end
        
            % === Donn√©es ===
            N = config.NumberOfPlates;
            mm = 1000;
            mm2 = 1e6;
        
            % Table des plaques
            T1 = table( ...
                (1:N)', ...
                round(config.PlatesRealPorosity(:) * 100, 2), ...
                round(config.PlatesHolesRadius(:) * mm, 2), ...
                round(config.SlitsWidth(1:N)' * mm, 2), ...
                round(config.PlatesThickness(:) * mm, 2), ...
                round(config.CavitiesThickness(:) * mm, 2), ...
                config.PlatesDepthHolesNumber(:), ...
                config.PlatesWidthHolesNumber(:), ...
                round(config.PlatesWidthHolesDistance(:) * mm, 2), ...
                'VariableNames', { ...
                    'PlateIndex', ...
                    'Porosity', ...
                    'HoleRadius_mm', ...
                    'SlitWidth_mm', ...
                    'PlateThickness_mm', ...
                    'CavityThickness_mm', ...
                    'DepthHolesNumber', ...
                    'WidthHolesNumber', ...
                    'WidthHolesDistance_mm' ...
                } ...
            );
        
            % Param√®tres globaux
            T2 = table( ...
                config.NumberOfPlates, ...
                config.CavitiesDepth * mm, ...
                config.CavitiesWidth * mm, ...
                config.InputSection * mm2, ...
                string(config.EndStatus), ...
                'VariableNames', { ...
                    'NumberOfPlates', ...
                    'CavitiesDepth_mm', ...
                    'CavitiesWidth_mm', ...
                    'InputSection_mm2', ...
                    'EndStatus' ...
                } ...
            );
        
            % === √âcriture Excel avec xlswrite (compatible et s√ªr) ===
            try
                xlswrite(filename, [T1.Properties.VariableNames; table2cell(T1)], 'PerPlateData');
                xlswrite(filename, [T2.Properties.VariableNames; table2cell(T2)], 'GlobalParameters');
                fprintf("‚úÖ Rapport cr√©√© avec succ√®s : %s\n", filename);
            catch ME
                error("Erreur lors de l‚Äô√©criture Excel : %s", ME.message);
            end
        end

    end

    methods (Static, Access = public)
        function config = create_config(number_of_plates, cavities_depth, cavities_width, slits_width, ...
        plates_holes_radius,...
        plates_thickness, cavities_thickness)
            
            config = {};
            config.NumberOfPlates = number_of_plates;
            config.EndStatus = 'closed';

            % Param√®tres glbaux
            config.CavitiesDepth = cavities_depth;
            config.CavitiesWidth = cavities_width;
            config.InputSection = cavities_width*cavities_depth;

            % Param√®tres variables en fonction des cellules
            config.PlatesThickness = perso_interp_config(plates_thickness, number_of_plates);
            config.CavitiesThickness = perso_interp_config(cavities_thickness, number_of_plates);
            % config.SlitsWidth = perso_interp_config(slits_width, number_of_plates + 1);
            config.PlatesHolesRadius = perso_interp_config(plates_holes_radius, number_of_plates);

            % D√©finition de la porosit√© √† partir de la r√©partition des perforations
            config.PlatesDepthHolesNumber = plates_depth_holes_number;
            config.PlatesWidthHolesNumber = plates_width_holes_number;
            plates_holes_number = plates_depth_holes_number{:} .* plates_width_holes_number{:};
            plates_perforated_surface = pi*plates_holes_radius{:}.^2 .* plates_holes_number;
            plates_perforated_part_porosity = plates_perforated_surface ./ (slits_width{:} * cavities_depth);
            config.PlatesPerforatedPartPorosity = perso_interp_config({plates_perforated_part_porosity}, number_of_plates);         

            % D√©finition de la largeur de la fente en fonction du nombre de perforations en largeur et du rayon de perforation
            % On part du principe 
        end

        function config = create_explicit_config(number_of_plates, cavities_depth, cavities_width, slits_width, ...
            plates_holes_radius, plates_width_holes_distance, ...
            plates_depth_holes_number, plates_width_holes_number, ...
            plates_thickness, cavities_thickness)
            
            config = {};
            config.NumberOfPlates = number_of_plates;
            config.EndStatus = 'closed';

            % Param√®tres glbaux
            config.CavitiesDepth = cavities_depth;
            config.CavitiesWidth = cavities_width;
            config.InputSection = cavities_width*cavities_depth;

            % Param√®tres variables en fonction des cellules
            config.PlatesThickness = perso_interp_config(plates_thickness, number_of_plates);
            config.CavitiesThickness = perso_interp_config(cavities_thickness, number_of_plates);
            config.PlatesHolesRadius = perso_interp_config(plates_holes_radius, number_of_plates); % r
            config.PlatesDepthHolesNumber = perso_interp_config(plates_depth_holes_number, number_of_plates); % m
            config.PlatesWidthHolesNumber = perso_interp_config(plates_width_holes_number, number_of_plates); % n
            config.PlatesWidthHolesDistance = perso_interp_config(plates_width_holes_distance, number_of_plates); % d

            % D√©finition de la largeur de la fente en fonction du nombre de perforations en largeur et du rayon de perforation
            config.SlitsWidth = perso_interp_config({plates_width_holes_distance{:} .* plates_width_holes_number{:}}, number_of_plates+1);
            
            % D√©finition de la porosit√© √† partir de la r√©partition des perforations
            plates_holes_number = plates_depth_holes_number{:} .* plates_width_holes_number{:};
            plates_perforated_surface = pi*plates_holes_radius{:}.^2 .* plates_holes_number;
            config.PlatesPerforatedPartPorosity = plates_perforated_surface ./ (slits_width{:} * cavities_depth);
            config.PlatesRealPorosity = plates_perforated_surface / (cavities_width * cavities_depth);
        end

    
        function validate()

            % close all 
            figure()
            hold on
            title('Validation Rectangular MPPSBH');
            
            % Param√®tres de la configuration
            R = 30e-3;
            L = 100e-3;
            N = 10;
            rend = 1e-3;
            d = 0.5e-3;
            t = 0.2e-3;
            phi = 0.03;
            
            % cr√©ation de l'environnement
            env = create_environnement(23, 100800, 22, 1, 5000, 5000);

            %% Profil lin√©aire
            
            % calcul de la r√©ponse du mod√®le analytique
            alpha_model = classMPPSBH_Rectangular(classMPPSBH_Rectangular.create_config(N, R, R, {{R, rend, N+1, 1}}, {phi}, {d/2}, {t}, {L/N - t})).alpha(env);

            plot(env.w / (2*pi), alpha_model, 'Color', 'g', 'LineWidth', 1, 'DisplayName', 'Profil lin√©aire - Mod√®le');

            %% Profil quadratique

            % calcul de la r√©ponse du mod√®le analytique
            alpha_model = classMPPSBH_Rectangular(classMPPSBH_Rectangular.create_config(N, R, R, {{R, rend, N+1, 0.5}}, {phi}, {d/2}, {t}, {L/N - t})).alpha(env);

            plot(env.w / (2*pi), alpha_model, 'Color', 'b', 'LineWidth', 1, 'DisplayName', 'Profil quadratique - Mod√®le');
            
            % affichage des r√©sultats
            xlabel("Fr√©quence (Hz)");
            ylabel("Coefficient d'Absorption");
            ylim([0 1]);
            xlim([0 3000]);
            legend();
        end
    end
end
